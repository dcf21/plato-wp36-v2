# -*- coding: utf-8 -*-
# lc_reader_lcsg.py

"""
Read the ASCII lightcurves generated by the lightcurve stitching group, and turn them into Lightcurve objects.
"""

import numpy as np
import os
import re
import gzip

from typing import Optional

from .lightcurve import LightcurveArbitraryRaster


def read_lcsg_lightcurve(file_path: str, gzipped: Optional[bool] = None, cut_off_time: Optional[float] = None):
    """
    Read a lightcurve from an ASCII data file.

    ASCII file should have three columns:
    time [days] ; flux ; flag

    :param file_path:
        The full path to the input data file.
    :type file_path:
        str
    :param gzipped:
        Boolean flag indicating whether the input datafiles have been gzipped. If this is not set, a guess is made
        from the filename suffix.
    :type gzipped:
        bool
    :param cut_off_time:
        Only read lightcurve up to some cut off time
    :type cut_off_time:
        float
    :return:
        A <LightcurveArbitraryRaster> object.
    """

    # Empty data structures to hold lightcurve data
    times = []  # days
    fluxes = []
    uncertainties = []
    flags = []

    # Extract the filename from the supplied file path
    filename = os.path.split(file_path)[1]

    # Build a dictionary of metadata to associate with this lightcurve
    metadata = {
        'filename': filename
    }

    # Determine whether input file is gzipped
    if gzipped is None:
        gzipped = file_path.endswith(".gz")

    # Look up file open function
    file_opener = gzip.open if gzipped else open

    # Loop over lines of input file
    with file_opener(file_path, "rt") as file:
        for line in file:
            # Ignore blank lines and comment lines
            if len(line) == 0 or line[0] == '#':
                # Check for metadata item
                test = re.match(r"# #(.*)=(.*)", line)
                if test is not None:
                    metadata_key = test.group(1).strip()
                    metadata_value = test.group(2).strip()

                    # If metadata value is a float, convert it to a float. Otherwise, keep it as string.
                    try:
                        metadata_value = float(metadata_value)
                    except ValueError:
                        pass

                    metadata[metadata_key] = metadata_value

                # ... otherwise ignore this line
                continue

            # Unpack data
            words = line.split(',')
            time = float(words[0])  # days
            flux = float(words[1])
            flag = float(words[2])
            uncertainty = 0

            # Check we have not exceeded cut-off time
            if cut_off_time is not None and time > cut_off_time:
                continue

            # Read three columns of data
            times.append(time)
            fluxes.append(flux)
            flags.append(flag)
            uncertainties.append(uncertainty)

    # Convert into a Lightcurve object
    lightcurve = LightcurveArbitraryRaster(times=np.asarray(times),  # days
                                           fluxes=np.asarray(fluxes),
                                           uncertainties=np.asarray(uncertainties),
                                           flags=np.asarray(flags),
                                           metadata=metadata
                                           )

    # Return lightcurve
    return lightcurve
